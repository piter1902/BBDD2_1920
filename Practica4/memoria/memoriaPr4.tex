\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{listings}
\usepackage[hidelinks]{hyperref}
\usepackage{lscape}
\usepackage{rotating}
\usepackage{pdflscape}

\lstset{
basicstyle=\ttfamily,
frame=single,
language=SQL,
tabsize=2,
showstringspaces=false,
literate=%
    {á}{{\'a}}1
    {é}{{\'e}}1
    {è}{{\`e}}1
    {í}{{\'i}}1
    {ó}{{\'o}}1
    {ú}{{\'u}}1
}

\begin{document}

\begin{titlepage}
	\title{{\Huge \textbf{Práctica 4 - Bases de Datos 2}}}
	\author{
	  Hayk Kocharyan\\
	  757715@unizar.es
	  \and
	  Juan José Tambo Tambo\\
	  755742@unizar.es
	  \and
	  Pedro Tamargo Allué\\
	  758267@unizar.es
	  \and
	  Jesús Villacampa Sagaste\\
	  755739@unizar.es
	}
	\date{\today}
	
	\clearpage\maketitle
	\thispagestyle{empty}
	\tableofcontents
	\listoffigures
\end{titlepage}

\section{Esfuerzos invertidos}

\begin{itemize}
\item Hayk:
\item Juan José:
\item Pedro:
\item Jesús:
\end{itemize}

\section{Modelo conceptual}

Durante el desarrollo de la práctica 1 se diseñó una base de datos para un banco que quería gestionar cuentas con múltiples propietarios, diferentes tipos de cuentas (cuentas ahorro y cuentas corrientes), operaciones (transacciones entre cuentas, o movimientos de dinero en efectivo) y las sucursales de la entidad.\\
En la Figura \ref{fig:diagramaer} se puede observar el esquema entidad relación sobre el problema planteado. Se ha planteado las relaciones entre los distintos tipos de cuentas como una generalización, ya que todas comparten ciertos atributos como el número de cuenta, el \emph{IBAN}, la fecha de apertura y el saldo restante. Esta generalización es exclusiva ya que no se considera posible la capacidad de que una cuenta pertenezca a los dos tipos de entidades al mismo tiempo. También, se trata de una generalización total ya que no se considera el caso de que una cuenta no pertenezca a algunos de las entidades derivadas de \emph{Cuenta}.\\
Con transacción ocurre lo mismo, una transferencia entre cuentas y las operaciones de retirada o ingreso de efectivo se pueden generalizar en una nueva entidad \emph{Transacción} con los atributos comunes a ambas entidades, tales como: el número de la transacción, la fecha y hora de la misma, su importe y una descripción a modo de concepto. Se trata de una generalización exclusiva ya que una transferencia no puede pertenecer a los dos subtipos a la vez. También, se trata de una generalización total ya que en el contexto del problema no tiene sentido que exista una transferencia que no pertenezca a \emph{Operación (operaciones en efectivo)} o a \emph{Transferencia (transferencia de saldo entre cuentas)}.\\
Se ha decidido que \emph{Transacción} debía ser débil respecto a \emph{cuenta} ya que depende en existencia e identificación de \emph{cuenta}, por lo tanto la relación \emph{Realizar} es una relación \emph{1:N} entre \emph{Cuenta} y \emph{Transacción}. No obstante, existe una transacción que no indica la debilidad de la entidad \emph{Transacción} respecto a \emph{Cuenta}, la relación \emph{Recibir}, una relación \emph{1:N} que relaciona las entidades \emph{Cuenta} y \emph{Transferencia} , y cuyo significado es relacionar una transferencia con la cuenta beneficiaria.\\
Los clientes titulares de una cuenta se reflejan en la entidad \emph{Cliente}, que almacena el DNI, el nombre, los apellidos la dirección y el email. Se ha decidido que el \emph{DNI} sea la clave primaria ya que es único para los ciudadanos.\\
La relación de \emph{Cliente} con \emph{Cuenta} se encuentra en \emph{Poseer}, una relación \emph{M:N} que posibilita que una cuenta tenga más de un titular.\\
Para el almacenamiento de las sucursales de la entidad bancaria, se ha diseñado una entidad \emph{Sucursal}, que almacena el código de la entidad, su dirección postal y el teléfono de la oficina. Se ha decidido que el código de la sucursal sea la clave primaria que identifique a las sucursales ya que dentro de la misma entidad bancaria no existen dos sucursales con el mismo código.\\
Se ha considerado que las transacciones se tienen que realizar en una sucursal, por lo tanto existe una relación entre \emph{Transacción} y \emph{Sucursal}. También, una cuenta corriente debe ser abierta en una determinada sucursal de la entidad.\\

Como apoyo hacia el desarrollo orientado a objetos con \emph{Java} se ha utilizado como referencia un diagrama de clases \emph{UML} (Figura \ref{fig:diagramauml}) con la misma semántica que el diagrama entidad relación explicado anteriormente.\\

\textbf{Aquí explicaremos el diagrama ER de banquito, para que lo tengan presente (Figura \ref{fig:diagramaer}).}

\section{Entorno de trabajo y ejecución}

Para la realización de la práctica se ha utilizado la herramienta \emph{Apache Maven\footnote{\url{https://maven.apache.org/}}} para compilar, gestionar las dependencias y ejecutar el código.\\
Como entorno de desarrollo se va a utilizar \emph{Visual Studio Code\footnote{\url{https://code.visualstudio.com/}}}, un editor de código abierto que tiene integraciones con diferentes herramientas (como \emph{Maven}) y lenguajes de programación.\\

Para configurar la herramienta \emph{Maven} debemos crear un proyecto con la forma especificada en la Figura \ref{fig:estructuraMAVEN}. El fichero \emph{pom.xml} (\emph{Project Object Model}) se corresponde con el fichero que utiliza \emph{Maven} para gestionar las dependencias y establecer distintas etapas del ciclo de vida del código, tales como \emph{COMPILE}, \emph{EXEC} o \emph{CLEAN}.\\
Para no utilizar un fichero \emph{pom.xml} vacío desde 0, se ha procedido a utilizar un \emph{archetype}, el cual proporciona una estructura básica. El \emph{archetype} utilizado ha sido: \emph{archetype-quickstart-jdk8}.\\
El código se desarrollará en el directorio \emph{src/main/java/package-name}, donde \emph{package-name} se corresponde con el \emph{groupId} especificado en el fichero \emph{pom.xml}.\\
Para ejecutar el código generado primero debemos compilarlo, para ello, desde la línea de comandos del sistema operativo, en el mismo directorio donde se encuentre el fichero \emph{pom.xml} escribiremos la siguiente orden:

\begin{lstlisting}
# Limpiamos los resultados de una ejecución anterior
mvn clean
# Primero compilamos el código Java
mvn compile
# Donde package-name se corresponde con el groupId especificado.
mvn exec:java -Dexec.mainClass="package-name.App"
\end{lstlisting}

Para añadir las dependencias de los distintos \emph{JAR} que necesite el proyecto, hay que añadirlas en el apartado \emph{dependencies} del fichero \emph{pom.xml} de la siguiente forma:

\begin{lstlisting}
<dependencies>
	<dependency>
		<groupId>org.junit.jupiter</groupId>
		<artifactId>junit-jupiter-api</artifactId>
		<version>${junit.version}</version>
		<scope>test</scope>
	</dependency>
	<dependency>
		<groupId>org.junit.jupiter</groupId>
		<artifactId>junit-jupiter-engine</artifactId>
		<version>${junit.version}</version>
		<scope>test</scope>
	</dependency>
	<!--  Driver JDBC Oracle  -->
	<dependency>
		<groupId>com.oracle.database.jdbc</groupId>
		<artifactId>ojdbc8</artifactId>
		<version>19.6.0.0</version>
	</dependency>
	<!--  Jar de Hibernate Core  -->
	<dependency>
		<groupId>org.hibernate</groupId>
		<artifactId>hibernate-core</artifactId>
		<version>5.4.15.Final</version>
	</dependency>
	<!--  Jar de entity manager  -->
	<dependency>
		<groupId>org.hibernate</groupId>
		<artifactId>hibernate-entitymanager</artifactId>
		<version>5.4.15.Final</version>
	</dependency>
	<!--  javax.persistence  -->
	<dependency>
		<groupId>javax.persistence</groupId>
		<artifactId>persistence-api</artifactId>
		<version>1.0.2</version>
	</dependency>
</dependencies>
\end{lstlisting}

Siendo cada elemento entre las etiquetas \emph{dependency} una dependencia que \emph{Maven} tiene que resolver. Para obtener la información acerca de la dependencia se puede consultar el repositorio de \emph{Maven Central\footnote{\url{https://search.maven.org/}}}. En este repositorio se puede realizar una búsqueda de la dependencia y obtener información de la misma. En la Figura \ref{fig:mavenCentral} se puede observar el resultado de la búsqueda del driver \emph{JDBC} de \emph{Oracle} utilizando este sistema. En la parte derecha de la misma se puede observar que se proporciona la etiqueta \emph{dependency} que ha sido añadida al fichero \emph{pom.xml}.\\

Tras la configuración de la herramienta es necesaria la configuración de \emph{JPA}, a partir del fichero \emph{persistence.xml}. Este fichero debe esta alojado en el \emph{Classpath} del proyecto, dentro del directorio \emph{META-INF}. Por lo tanto se ha creado un directorio \emph{src/main/resources/META-INF/} en el cual se alojará este fichero. Para la configuración de la unidad de persistencia se utilizará la base de datos \emph{Oracle} ubicada en \emph{danae04.cps.unizar.es}. El fichero \emph{persistence.xml} tendrá la siguiente forma:

\begin{lstlisting}
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence 
             http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd" 
             version="2.0">
	<persistence-unit name="UnidadPersistenciaAlumnos"
			 transaction-type="RESOURCE_LOCAL">
		<provider>org.hibernate.ejb.HibernatePersistence</provider>
		<properties>
		   <property name="hibernate.dialect" 
		   	value="org.hibernate.dialect.Oracle8iDialect" />
		   <property name="hibernate.show_sql" value="true"/>		
		   <property name="hibernate.hbm2ddl.auto" value="create"/>
		  
		   
		   <property name="javax.persistence.jdbc.driver" 
		   	value="oracle.jdbc.driver.OracleDriver"/>
		   <property name="javax.persistence.jdbc.url" 
		   	value="jdbc:oracle:thin:@danae04.cps.unizar.es:1521:barret"/>
		   <property name="javax.persistence.jdbc.user" value=""/>
		   <property name="javax.persistence.jdbc.password" value=""/>		   
		   

		</properties>
	</persistence-unit>
</persistence>
\end{lstlisting}

Tras la ejecución del código \emph{JPA} puede aparecer este error:

\begin{lstlisting}
[WARNING] thread Thread[Timer-0,5,bases2.App] was interrupted but is 
	still alive after waiting at least 15000msecs
[WARNING] thread Thread[Timer-0,5,bases2.App] will linger despite 
	being asked to die via interruption
[WARNING] thread Thread[InterruptTimer,5,bases2.App] will linger 
	despite being asked to die via interruption
[WARNING] thread Thread[Hibernate Connection Pool Validation 
	Thread,5,bases2.App] will linger despite being asked to die 
	via interruption
[WARNING] NOTE: 3 thread(s) did not finish despite being asked to 
	via interruption. This is not a problem with exec:java, 
	it is a problem with the running code. 
	Although not serious, it should be remedied.
[WARNING] Couldn't destroy threadgroup 
	org.codehaus.mojo.exec.ExecJavaMojo$IsolatedThreadGroup
	[name=bases2.App,maxpri=10]
java.lang.IllegalThreadStateException
    at java.lang.ThreadGroup.destroy (ThreadGroup.java:776)
    at [...]
\end{lstlisting}

Este error es debido a que en el final del código un proceso \emph{Daemon} se encarga de monitorizar que todos los hilos (\emph{Threads}) terminen correctamente. Para solventar este error podemos utilizar este otro comando para ejecutar el código:

\begin{lstlisting}
mvn exec:java 
	-Dexec.mainClass="package-name.App" 
	-Dexec.cleanupDaemonThreads=false
\end{lstlisting}

\textbf{Aquí le explicaremos que usamos visual code con maven y le explicaremos como se ejecuta.}

\section{Generación de esquema lógico con JPA}

Para la generación del esquema lógico utilizando \emph{JPA} se ha  utilizado el diagrama de clases de la Figura \ref{fig:diagramauml}. El primer paso de la generación ha sido la confección de las clases \emph{Java} utilizando las anotaciones necesarias. En este caso, se han utilizado las anotaciones \emph{@Entity} para marcar las entidades y las etiquetas \emph{@Column} para las columnas. Para las columnas se ha añadido un atributo \emph{name} para especificar el nombre de esa columna en la base de datos y así conocer los nombres de las columnas.\\
Para que \emph{JPA} funcione correctamente se deben definir los métodos \emph{hashCode() y equals()}. También, en el ámbito de las consultas es conveniente definir un método \emph{toString()} para obtener una salida comprensible del contenido de cada uno de los objetos. También es necesario que las clases tengan una estructura tipo \emph{Java Bean\footnote{\url{https://es.wikipedia.org/wiki/JavaBean}}}, esto implica que las clases deben disponer de un constructor por defecto (se llama sin parámetros) y métodos \emph{getters} y \emph{setters} para el acceso directo a cada uno de sus atributos, que deberán ser marcados como privados para impedir su acceso directo desde fuera de la propia clase.\\
Para resolver la herencia en este primer esquema lógico se ha decidido establecer las \emph{superclases} \emph{Cuenta} y \emph{Transacción} como clases abstractas. De esta manera no podrán ser instanciadas y por lo tanto se obligará a que la herencia sea obligatoria. Además al utilizar dos subclases, la herencia será disjunta ya que un objeto no puede pertenecer a dos subclases al mismo tiempo en este modelo conceptual.\\
El mecanismo predeterminado para la resolución de estas herencias ha sido el de crear una sola tabla con el nombre del padre con todos los atributos del padre y los específicos de cada uno de los hijos. Para determinar si una tupla en la base de datos pertenece a un subtipo o a otro se dispone de una columna (por defecto, \emph{DTYPE}) que contiene el nombre del subtipo cuyos valores se encuentran con valores permitidos para ese subtipo.\\
Sobre las relaciones, se ha utilizado una relación \emph{ManyToMany} bidireccional entre \emph{Cliente} y \emph{Cuenta}, siendo cliente la parte poseedora. Esta acción genera una tabla nueva \emph{Cliente\_{}Cuenta}, que representará lo mismo que la tabla \emph{Poseer} de la base de datos de \emph{Banquito}.\\
No se han utilizado más relaciones bidireccionales pero es de destacar la relación \emph{ManyToOne} unidireccional entre \emph{Transacción} y \emph{Cuenta}, ya que transacción es una entidad débil ante cuenta. La columna resultante de esta relación actúa también como parte de la clave primaria al utilizarse la anotación \emph{@Id}, siendo la clave primaria \emph{(NumTransaccion, realizante)}.\\


\textbf{Aquí explicaremos como hemos desarrollado el esquema lógico desde 0 con JPA.}

\section{Adopción de un esquema lógico preexistente con JPA}

Partiendo de las clases desarrolladas en el apartado anterior, se va a proceder a realizar las modificaciones sobre las mismas para adaptar al esquema lógico existente. Esta tarea no ha resultado especialmente difícil ya que \emph{JPA} provee muchas anotaciones para modificar el comportamiento del esquema que se va a generar o que se va a adoptar. Para facilitar esta tarea se ha modificado un campo del fichero \emph{persistence.xml}, el campo \emph{hibernate.hbm2ddl.auto} adoptará el valor \emph{validate}. Esto comprobará si el esquema generado por \emph{JPA} coincide con el esquema existente en el remoto especificado en ese mismo fichero. No realiza ninguna modificación sobre la base de datos.\\
Para dejar claro el nombre de las tablas sobre las que actúan cada una de las entidades (\emph{@Entity}) desarrolladas se va a utilizar la anotación (\emph{@Table(name = "[...]")}) .\\
Las relaciones desarrolladas anteriormente se han mantenido, no obstante se ha utilizado la anotación \emph{@JoinColumn} para establecer atributos tales como el nombre de la columna, restricciones de unicidad.\\
En la relación \emph{ManyToMany} entre \emph{Cliente} y \emph{Cuenta} se ha utilizado la anotación \emph{@JoinTable} de la siguiente manera:

\begin{lstlisting}
@ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
@JoinTable(
  name = "POSEER",
  joinColumns = @JoinColumn(
    referencedColumnName = "DNI",	name = "DNI"
  ),
  inverseJoinColumns = @JoinColumn(
    referencedColumnName = "NUM_CUENTA", name = "NUM_CUENTA"
  )
)
private List<Cuenta> cuentas;
\end{lstlisting}

Con esta anotación se ha establecido que la relación entre cliente y cuenta se establecerá sobre una tabla \emph{POSEER} con columnas \emph{DNI} referenciando a \emph{Cliente.DNI} y con la columna \emph{NUM\_{}CUENTA} referenciando a \emph{Cuenta.NUM\_{}CUENTA}.\\

Sobre la herencia, se han utilizado distintas estrategias de las propuestas por \emph{JPA}, en este caso, para la tabla cuenta se ha utilizado la estrategia \emph{JOINED}, la cual divide los campos específicos de la tabla padre en una tabla y los campos específicos de cada subtipo en sus respectivas tablas. En las tablas de los subtipos para establecer el nombre de la columna que actúa como clave primaria se utiliza la anotación \emph{@PrimaryKeyJoinColumn} con el atributo \emph{name}, en este caso se establecerá \emph{name = ``ID\_{}CUENTA''} para que coincidan con el esquema lógico preexistente.\\
En el caso de la herencia entre \emph{Transacción, Transferencia y Operación}, se ha establecido un mecanismo de herencia distinto. En este caso la superclase (transacción) no será una entidad, si no que se utilizará la anotación \emph{@MappedSuperclass} para indicar que esta superclase no se persistirá como una tabla en la base de datos, pero sus campos si que serán persistidos en cada uno de sus subtipos (transferencia y operación).

\textbf{Aquí le explicaremos el proceso de acomodación del esquema relacional de la base de datos con JPA. Le explicaremos lo del \emph{validate} y le mostraremos nuestros problemas.}

\section{Consultas con JPA}

\textbf{Aquí se expondrán las consultas, con su código SQL, JPQL, Criteria API}.\\
Para la elaboración de las consultas en \emph{JPA} se han propuesto 5 consultas diferentes y se han abordado tanto para el esquema lógico generado con \emph{JPA} como para el esquema lógico preexistente adaptado. También se han utilizado los diferentes lenguajes de consultas propuestos (SQL, JPQL y Criteria). 
Para cada una de las consultas realizadas con \textit{JPA} y \textit{Criteria API}, se han creado dos clases adicionales. La primera de ella es una clase de \textit{Java} que posee tantos atributos como los indicados en la consulta. La otra clase es la encargada de atribuir cada una de las columnas de la consulta a los atributos correspondientes de la clase de \textit{Java}. Esta clase \textit{Transformadora} deriva de la clase \textit{org.hibernate.transform.ResultTransformer} de \textit{Hibernate}. Tras comparar varios resultados en internet, todos coinciden en que esta es la mejor forma de mostrar las consultas de \textit{JPQ} actualmente.
Además, \textit{JPA} permite realizar consulas en \textit{SQL} utilizando la función \textit{createNativeQuery}.
Las consultas propuestas son las siguientes:

\begin{itemize}
\item Consulta 1: Clientes que más dinero han extraído de sus cuentas
\item Consulta 2: Sucursales en las que los clientes menores de 30 años tienen cuentas corrientes.
\item Consulta 3: Última transferencia de todas cuentas de todos los clientes
\item Consulta 4: Máximo movimiento (de ingreso) en una transacción en cada una de las cuentas de cada cliente.
\item Consulta 5: Ingreso total de dinero de las cuentas del usuario mas mayor
\end{itemize}

La consulta 1 se ha realizado para ambas versiones en \textit{SQL}, \textit{JPQL} y \textit{Criteria.}
Los códigos para la versión del esquema lógio creado son:\\
\textbf{Código para \textit{SQL}:}
\begin{lstlisting}
String query_sql = "select cl.nombre, tr.realizante_numcuenta,
    SUM(tr.importe) "
	+ "from transaccion tr JOIN cliente_cuenta pos ON 
	tr.realizante_numcuenta = pos.cuentas_numcuenta "
	+ "JOIN cliente cl ON pos.propietarios_DNI = cl.DNI 
	where tr.DTYPE = 'Operacion' AND tr.tipo = 'Retirada' "
	+ "GROUP BY tr.realizante_numcuenta, cl.nombre ORDER BY 
	SUM(importe) DESC";

EntityManager em = emf.createEntityManager();
javax.persistence.Query q_sql = em.createNativeQuery(query_sql);
List<Object[]> result_sql = q_sql.getResultList();

System.out.println("------ Mostrando Query1 en SQL ------");

for (Object[] res : result_sql) {
System.out.println("[ Cliente: " + res[0] + ", Cuenta: " 
	+ res[1] + ",Suma: " + res[2] + "]");
}
\end{lstlisting}

\textbf{Código para \textit{JPQL}:}
\begin{lstlisting}
String query_text = "SELECT cl.Nombre, op.realizante.numCuenta,
	 SUM(op.importe) "
	+ "FROM Operacion op JOIN op.realizante realizantes "
	+ "JOIN realizantes.propietarios cl " + "WHERE op.tipo = 'Retirada'"
	+ "GROUP BY op.realizante.numCuenta, cl.Nombre " 
	+ "ORDER BY SUM(op.importe) DESC";

javax.persistence.Query query1 = em.createQuery(query_text);

@SuppressWarnings("unchecked")
List<Query1> results = query1.unwrap(org.hibernate.query.Query.class)
.setResultTransformer(new Query1Transformer()).getResultList();

System.out.println("------ Mostrando Query1 en JPQL ------");

for (Query1 q : results) {
System.out.println(q);
}

\end{lstlisting}
\textbf{Código para \textit{Criteria}:}
\begin{lstlisting}
javax.persistence.criteria.CriteriaBuilder cb = 
	em.getCriteriaBuilder();

javax.persistence.criteria.CriteriaQuery query = 
	cb.createQuery(Query1.class);
javax.persistence.criteria.Root<Operacion> operacionTable = 
	query.from(Operacion.class);
javax.persistence.criteria.Join<Operacion, Cuenta> cuentaJoin = 
	operacionTable.join("realizante");
javax.persistence.criteria.Join<Cuenta, Cliente> clienteJoin = 
	cuentaJoin.join("propietarios");

List<javax.persistence.criteria.Predicate> predicates = 
	new ArrayList<>();
predicates.add(cb.equal(operacionTable.get("tipo"), "Retirada"));

query.multiselect(clienteJoin.get("Nombre"),cuentaJoin.get("numCuenta"),
cb.sum(operacionTable.get("importe")));

query.where(predicates.stream().
	toArray(javax.persistence.criteria.Predicate[]::new));
query.groupBy(cuentaJoin.get("numCuenta"), clienteJoin.get("Nombre"));

List<javax.persistence.criteria.Order> order = new ArrayList<>();
order.add(cb.desc(cb.sum(operacionTable.get("importe"))));

query.orderBy(order);

TypedQuery<Query1> typedQuery = em.createQuery(query);

List<Query1> resultList = typedQuery.getResultList();

System.out.println("------ Mostrando Query1 en Criteria API ------");

for (Query1 q : resultList) {
		System.out.println(q);
	}

\end{lstlisting}

\bigbreak

Los códigos para la versión del esquema lógio creado son:\\
\bigbreak
\textbf{Código para \textit{SQL}:}
\begin{lstlisting}
String query_sql = "select cl.nombre, op.num_cuenta_realizante, 
	SUM(op.importe) "
	+ "from operacion op JOIN poseer pos ON op.num_cuenta_realizante =
		pos.num_cuenta "
	+ "JOIN cliente cl ON pos.DNI = cl.DNI where op.tipo = 'Retirada' 
		GROUP BY "
	+ "op.num_cuenta_realizante, cl.nombre ORDER BY SUM(importe) DESC";

EntityManager em = emf.createEntityManager();
javax.persistence.Query q_sql = em.createNativeQuery(query_sql);
List<Object[]> result_sql = q_sql.getResultList();

System.out.println("------ Mostrando Query1 en SQL ------");

for (Object[] res : result_sql) {
System.out.println("[ Nombre: " + res[0] + ", Cuenta: " 
	+ res[1] + ",Suma: " + res[2] + "]");
}
\end{lstlisting}

\textbf{Código para \textit{JPQL}:}
\begin{lstlisting}
String query_text = "SELECT cl.Nombre, op.realizante.numCuenta,
	 SUM(op.importe) "
	+ "FROM Operacion op JOIN op.realizante realizantes "
	+ "JOIN realizantes.propietarios cl " + "WHERE op.tipo =
	 'Retirada' "
	+ "GROUP BY op.realizante.numCuenta, cl.Nombre " 
	+ "ORDER BY SUM(op.importe) DESC";

javax.persistence.Query query1 = em.createQuery(query_text);

@SuppressWarnings("unchecked")
List<Query1> results = query1.unwrap(org.hibernate.query.Query.class)
.setResultTransformer(new Query1Transformer()).getResultList();

System.out.println("------ Mostrando Query1 en JPQL ------");

for (Query1 q : results) {
System.out.println(q);
}
\end{lstlisting}
\textbf{Código para \textit{Criteria}:}
\begin{lstlisting}
javax.persistence.criteria.CriteriaBuilder cb = 
	em.getCriteriaBuilder();

javax.persistence.criteria.CriteriaQuery query = 
	cb.createQuery(Query1.class);
javax.persistence.criteria.Root<Operacion> operacionTable = 
	query.from(Operacion.class);
javax.persistence.criteria.Join<Operacion, Cuenta> cuentaJoin = 
	operacionTable.join("realizante");
javax.persistence.criteria.Join<Cuenta, Cliente> clienteJoin = 
	cuentaJoin.join("propietarios");

List<javax.persistence.criteria.Predicate> predicates = 
	new ArrayList<>();
predicates.add(cb.equal(operacionTable.get("tipo"), "Retirada"));

query.multiselect(clienteJoin.get("Nombre"), 
cuentaJoin.get("numCuenta"),cb.sum(operacionTable.get("importe")));

query.where(predicates.stream().
	toArray(javax.persistence.criteria.Predicate[]::new));
query.groupBy(cuentaJoin.get("numCuenta"), clienteJoin.get("Nombre"));

List<javax.persistence.criteria.Order> order = new ArrayList<>();
order.add(cb.desc(cb.sum(operacionTable.get("importe"))));

query.orderBy(order);

TypedQuery<Query1> typedQuery = em.createQuery(query);

List<Query1> resultList = typedQuery.getResultList();

System.out.println("------ Mostrando Query1 en Criteria API ------");

for (Query1 q : resultList) {
System.out.println(q);
}

\end{lstlisting}

\bigskip

La \textbf{consulta 2} también se ha realizado en \textit{SQL}, \textit{JPQL} y \textit{Criteria} para ambas versiones.
Los códigos para la versión del esquema lógico creado son los siguientes:\\

\textbf{Código para \textit{SQL}:}
\begin{lstlisting}
String query_sql = "SELECT suc.CODIGO,cl.NOMBRE,cl.EDAD,cc.NUMCUENTA "
+ "FROM Sucursal suc JOIN CUENTA cc ON suc.CODIGO = cc.sucursal_codigo"
+ "JOIN CLIENTE_CUENTA pos ON cc.numCuenta = pos.cuentas_numcuenta "
+ "JOIN CLIENTE cl ON pos.PROPIETARIOS_DNI = cl.DNI WHERE 
	cl.EDAD < 30 AND cc.DTYPE = 'CuentaCorriente' "
+ "ORDER BY suc.codigo";

EntityManager em = emf.createEntityManager();
javax.persistence.Query q_sql = em.createNativeQuery(query_sql);
List<Object[]> result_sql = q_sql.getResultList();

System.out.println("------ Mostrando Query2 en SQL ------");

for (Object[] res : result_sql) {
System.out.println("[ Sucursal: " + res[0] + ", Cliente: "
	+ res[1] + ", Edad: " + res[2]
	+ ", Cuenta: " + res[3] + "]");
}
\end{lstlisting}

\textbf{Código para \textit{JPQL}:}
\begin{lstlisting}
String query_text = "SELECT suc.codigo, cl.Nombre, cl.Edad,
	cc.numCuenta " + "FROM Cliente cl "
+ "JOIN cl.cuentas cc " + "JOIN cc.sucursal suc " + 
	"WHERE cl.Edad < 30 "
+ "ORDER BY suc.codigo";

javax.persistence.Query query2 = em.createQuery(query_text);

// Source: https://vladmihalcea.com/hibernate-resulttransformer/
@SuppressWarnings("unchecked")
List<Query2> results = query2.unwrap(org.hibernate.query.Query.class)
.setResultTransformer(new Query2Transformer()).getResultList();

System.out.println("------ Mostrando Query2 en JPQL ------");

for (Query2 q : results) {
System.out.println(q);
}
\end{lstlisting}

\textbf{Código para \textit{Criteria}:}
\begin{lstlisting}
javax.persistence.criteria.CriteriaBuilder cb = em.getCriteriaBuilder();

javax.persistence.criteria.CriteriaQuery query = 
	cb.createQuery(Query2.class);
javax.persistence.criteria.Root<Cliente> clienteTable = 
	query.from(Cliente.class);
javax.persistence.criteria.Join<Cliente, Cuenta> cuentaJoin =
	clienteTable.join("cuentas");

// Seleccionamos tabla hija
javax.persistence.criteria.Join cuentaCorrienteJoin = 
	cb.treat(cuentaJoin, CuentaCorriente.class);

javax.persistence.criteria.Join<CuentaCorriente, Sucursal> 
	sucursalJoin = cuentaCorrienteJoin
.join("sucursal");

List<javax.persistence.criteria.Predicate> predicates = 
	new ArrayList<>();
predicates.add(cb.lt(clienteTable.get("Edad"), 30));

query.multiselect(sucursalJoin.get("codigo"), clienteTable.
	get("Nombre"), clienteTable.get("Edad"),
	cuentaCorrienteJoin.get("numCuenta")).distinct(true);
	
query.where(predicates.stream().
	toArray(javax.persistence.criteria.Predicate[]::new));

// Para poder hacer el Order By
List<javax.persistence.criteria.Order> order = new ArrayList<>();
order.add(cb.asc(sucursalJoin.get("codigo")));

query.orderBy(order);

TypedQuery<Query2> typedQuery = em.createQuery(query);

List<Query2> resultList = typedQuery.getResultList();

System.out.println("------ Mostrando Query2 en Criteria API ------");

for (Query2 row : resultList) {
System.out.println(row);
}
\end{lstlisting}

\bigbreak

Ls códigos para el esquema lógico existente son:\\

\textbf{Código para \textit{SQL}:}
\begin{lstlisting}
String query_sql = "SELECT suc.CODIGO, cl.NOMBRE, cl.EDAD, 
	cc.ID_CUENTA "
	+ "FROM Sucursal suc JOIN CUENTA_CORRIENTE cc ON suc.CODIGO = 
	cc.ID_SUCURSAL "
	+ "JOIN POSEER pos ON cc.ID_CUENTA = pos.NUM_CUENTA "
	+ "JOIN CLIENTE cl ON pos.DNI = cl.DNI 
	WHERE cl.EDAD < 30 " + "ORDER BY suc.codigo";

EntityManager em = emf.createEntityManager();
javax.persistence.Query q_sql = em.createNativeQuery(query_sql);
List<Object[]> result_sql = q_sql.getResultList();

System.out.println("------ Mostrando Query2 en SQL ------");

for (Object[] res : result_sql) {
System.out.println("[ Sucursal: " + res[0] + ", Cliente: " 
	+ res[1] + ", Edad: " + res[2]
	+ ", Cuenta: " + res[3] + "]");
}
\end{lstlisting}

\textbf{Código para \textit{JPQL}:}
\begin{lstlisting}
String query_text = "SELECT suc.codigo, cl.Nombre, cl.edad, 
	cc.numCuenta " + "FROM Cliente cl "
	+ "JOIN cl.cuentas cc " + "JOIN cc.sucursal suc " 
	+ "WHERE cl.edad < 30 "
	+ "ORDER BY suc.codigo";

javax.persistence.Query query2 = em.createQuery(query_text);

// Source: https://vladmihalcea.com/hibernate-resulttransformer/
@SuppressWarnings("unchecked")
List<Query2> results = query2.unwrap(org.hibernate.query.Query.class)
.setResultTransformer(new Query2Transformer()).getResultList();

System.out.println("------ Mostrando Query2 en JPQL ------");

for (Query2 q : results) {
System.out.println(q);
}
\end{lstlisting}

\textbf{Código para \textit{Criteria}:}
\begin{lstlisting}
javax.persistence.criteria.CriteriaBuilder cb = 
	em.getCriteriaBuilder();

javax.persistence.criteria.CriteriaQuery query = 
	cb.createQuery(Query2.class);
javax.persistence.criteria.Root<Cliente> clienteTable = 
	query.from(Cliente.class);
javax.persistence.criteria.Join<Cliente, Cuenta> cuentaJoin = 
	clienteTable.join("cuentas");

// Seleccionamos tabla hija
javax.persistence.criteria.Join cuentaCorrienteJoin = 
	cb.treat(cuentaJoin, CuentaCorriente.class);

javax.persistence.criteria.Join<CuentaCorriente, Sucursal> 
	sucursalJoin = cuentaCorrienteJoin
	.join("sucursal");

List<javax.persistence.criteria.Predicate> predicates = 
	new ArrayList<>();
predicates.add(cb.lt(clienteTable.get("edad"), 30));

query.multiselect(sucursalJoin.get("codigo"), 
	clienteTable.get("Nombre"), clienteTable.get("edad"),
	cuentaCorrienteJoin.get("numCuenta")).distinct(true);

query.where(predicates.stream().
	toArray(javax.persistence.criteria.Predicate[]::new));

// Para poder hacer el Order By
List<javax.persistence.criteria.Order> order = new ArrayList<>();
order.add(cb.asc(sucursalJoin.get("codigo")));

query.orderBy(order);

TypedQuery<Query2> typedQuery = em.createQuery(query);

List<Query2> resultList = typedQuery.getResultList();

System.out.println("------ Mostrando Query2 en Criteria API ------");

for (Query2 row : resultList) {
System.out.println(row);
}
\end{lstlisting}

\bigbreak
Para la consulta 3, para las dos versiones, se ha abordado la solución en \emph{JPQL} y \textit{SQL}. \\
El código para la versión de esquema lógico adaptado es el siguiente:

\textbf{Código para \textit{SQL}:}
\begin{lstlisting}
String query_sql = "SELECT cl.Nombre, p.num_cuenta, s1.fecha "
	+ "FROM (SELECT max(t.fecha) AS fecha,t.num_cuenta_realizante 
	from transaccion t "
	+ "GROUP BY t.num_cuenta_realizante) s1 "
	+ "JOIN poseer p ON p.num_cuenta = s1.num_cuenta_realizante 
	JOIN cliente cl ON p.DNI = cl.DNI "
	+ "GROUP BY cl.Nombre, p.num_cuenta, s1.fecha ORDER BY cl.Nombre";

EntityManager em = emf.createEntityManager();
javax.persistence.Query q_sql = em.createNativeQuery(query_sql);
List<Object[]> result_sql = q_sql.getResultList();

System.out.println("------ Mostrando Query3 en SQL ------");

for (Object[] res : result_sql) {
System.out.println("[ Cliente: " + res[0] + ", Cuenta: " + res[1] + ", Fecha: " + res[2] + "]");
}
\end{lstlisting}

\bigbreak
\textbf{Código para \textit{JPQL}:}

\begin{lstlisting}
	EntityManager em = emf.createEntityManager();
	String query_text = 
    "SELECT cl.Nombre, real.numCuenta, tr.fecha " +
    "FROM Transferencia tr JOIN tr.realizante real 
    JOIN real.propietarios cl " + 
    "WHERE tr.fecha IN ( SELECT MAX(tr2.fecha) FROM Transferencia tr2 
    WHERE tr2.realizante.numCuenta = tr.realizante.numCuenta) "+
    "GROUP BY cl.Nombre, real.numCuenta, tr.fecha ORDER BY cl.Nombre";

   javax.persistence.Query query3 = em.createQuery(query_text);

   @SuppressWarnings("unchecked")
   List<Query3> results = 
   query3.unwrap(org.hibernate.query.Query.class)
   .setResultTransformer(newQuery3Transformer()).getResultList();

   System.out.println("------ Mostrando Query3 en JPQL ------");

   for (Query3 q : results) {
       System.out.println(q);
   }
\end{lstlisting}

El código para la versión de esquema lógico creado es el siguiente:


\bigbreak
\textbf{Código para \textit{JPQL}:}

\begin{lstlisting}
        EntityManager em = emf.createEntityManager();
        String query_text = 
        "SELECT cl.Nombre, real.numCuenta, tr.fecha " +
        "FROM Transaccion tr JOIN tr.realizante real JOIN 
        real.propietarios cl " +  "WHERE tr.fecha IN 
        ( SELECT MAX(tr2.fecha) FROM Transaccion tr2 WHERE 
        tr2.realizante.numCuenta = tr.realizante.numCuenta) "+
        "GROUP BY cl.Nombre, real.numCuenta, tr.fecha 
        ORDER BY cl.Nombre";

        javax.persistence.Query query3 = em.createQuery(query_text);

        @SuppressWarnings("unchecked")
        List<Query3> results = 
        query3.unwrap(org.hibernate.query.Query.class)
        .setResultTransformer(new Query3Transformer()).getResultList();

        System.out.println("------ Mostrando Query3 en JPQL ------");

        for (Query3 q : results) {
                System.out.println(q);
        }
\end{lstlisting}


\bigbreak
\textbf{Código para \textit{SQL}:}
\begin{lstlisting}
String query_sql = "SELECT cl.NOMBRE, p.CUENTAS_NUMCUENTA,s1.FECHA "
	+ "FROM (SELECT max(t.FECHA) AS fecha, t.REALIZANTE_NUMCUENTA 
	from transaccion t "
	+ "GROUP BY t.REALIZANTE_NUMCUENTA) s1 "
	+ "JOIN CLIENTE_CUENTA p ON p.CUENTAS_NUMCUENTA = 
		s1.REALIZANTE_NUMCUENTA "
	+ "JOIN cliente cl ON p.PROPIETARIOS_DNI = cl.DNI GROUP BY "
	+ "cl.NOMBRE,p.CUENTAS_NUMCUENTA,s1.FECHA ORDER BY cl.NOMBRE";

EntityManager em = emf.createEntityManager();
javax.persistence.Query q_sql = em.createNativeQuery(query_sql);
List<Object[]> result_sql = q_sql.getResultList();

System.out.println("------ Mostrando Query3 en SQL ------");

for (Object[] res : result_sql) {
System.out.println("[ Cliente: " + res[0] + ", Cuenta: " + res[1] 
	+ ", Fecha: " + res[2] + "]");
}
\end{lstlisting}
\bigbreak
En cuanto a la consulta 4, se ha realizado en \textit{SQL} únicamente para la versión del esquema lógico adaptado, debido a que se necesita una unión entre dos tablas y \textit{JPQL} ni \textit{Criteria} lo admiten.

\textbf{Código para esquema lógico adaptado en \textit{SQL}:}
\begin{lstlisting}

String query_sql = "SELECT cl.Nombre, subquery1.Num_cuenta, 
	MAX(subquery1.importe) as importe "
	+ "FROM (SELECT tr.NUM_CUENTA_BENEFICIARIO AS Num_cuenta,
	 MAX(tr.importe) AS Importe "
	+ "FROM TRANSACCION tr GROUP BY tr.NUM_CUENTA_BENEFICIARIO "
	+ "UNION SELECT op.NUM_CUENTA_REALIZANTE AS Num_cuenta, 
	MAX(op.importe) AS Importe "
	+ "FROM OPERACION op WHERE op.tipo = 'Ingreso' 
	GROUP BY op.NUM_CUENTA_REALIZANTE ) subquery1 "
	+ "JOIN POSEER pos ON pos.Num_cuenta = subquery1.Num_cuenta 
	JOIN CLIENTE cl ON cl.DNI = pos.DNI "
	+ "GROUP BY subquery1.Num_cuenta, cl.NOMBRE ORDER BY cl.NOMBRE";

EntityManager em = emf.createEntityManager();
javax.persistence.Query q_sql = em.createNativeQuery(query_sql);
List<Object[]> result_sql = q_sql.getResultList();

System.out.println("------ Mostrando Query4 en SQL ------");

for (Object[] res : result_sql) {
	System.out.println("[ Nombre: " + res[0] + ", Cuenta: " 
	+ res[1] + ", Importe: " + res[2] + "]");
}
\end{lstlisting}
\bigbreak
Sin embargo, para el esquema creado por \textit{JPA}, sí que se ha realizado la consulta en \textit{JPQL} y \textit{SQL}, al no ser necesaria la unión entre \textit{transferencia} y \textit{operación} al juntarse en una única tabla \textit{Transacción}.

\bigbreak
\textbf{Código para \textit{JPQL}:}

\begin{lstlisting}
String query_text = "SELECT cl.Nombre, cuen.numCuenta, tr.importe " 
	+ "FROM Transaccion tr "
	+ "JOIN tr.realizante cuen JOIN cuen.propietarios cl " + 
	"WHERE tr.importe = "
	+ "(SELECT MAX(tr1.importe) as Importe "
	+ "FROM Transaccion tr1 WHERE tr1.realizante.numCuenta = 
	tr.realizante.numCuenta) "
	+ "ORDER BY cl.Nombre";

javax.persistence.Query query4 = em.createQuery(query_text);

// Source: https://vladmihalcea.com/hibernate-resulttransformer/
@SuppressWarnings("unchecked")
List<Query4> results = query4.unwrap(org.hibernate.query.Query.class)
.setResultTransformer(new Query4Transformer()).getResultList();

System.out.println("------ Mostrando Query4 en JPQL ------");

for (Query4 q : results) {
System.out.println(q);
}
\end{lstlisting}


\bigbreak
\textbf{Código para \textit{SQL}:}

\begin{lstlisting}
String query_sql = "SELECT cl.Nombre, subquery1.Num_cuenta,
	 MAX(subquery1.importe) as importe "
	+ "FROM (SELECT tr.REALIZANTE_NUMCUENTA AS Num_cuenta, 
	MAX(tr.importe) AS Importe "
	+ "FROM TRANSACCION tr GROUP BY tr.REALIZANTE_NUMCUENTA) subquery1 "
	+ "JOIN CLIENTE_CUENTA pos ON pos.CUENTAS_NUMCUENTA = 
	subquery1.Num_cuenta "
	+ "JOIN CLIENTE cl ON cl.DNI = pos.PROPIETARIOS_DNI 
	GROUP BY subquery1.Num_cuenta, cl.NOMBRE "
	+ "ORDER BY cl.NOMBRE";

EntityManager em = emf.createEntityManager();
javax.persistence.Query q_sql = em.createNativeQuery(query_sql);
List<Object[]> result_sql = q_sql.getResultList();

System.out.println("------ Mostrando Query4 en SQL ------");

for (Object[] res : result_sql) {
System.out.println(
"[ Nombre: " + res[0] + ", Cuenta: "
 + res[1] + ", Importe: " + res[2] + "]");
}

\end{lstlisting}


\bigbreak
Para la consulta 5, para las dos versiones, se ha abordado la solución en \emph{JPQL}. \\
El código para la versión de esquema lógico adaptado es el siguiente:

\begin{lstlisting}
	EntityManager em = emf.createEntityManager();
   	String query_text = 
    "SELECT cl.Nombre, realizantes.numCuenta, SUM(op.importe), 
    cl.edad "+ "FROM Operacion op JOIN op.realizante realizantes "
    + "JOIN realizantes.propietarios cl " + 
    "WHERE op.tipo = 'Ingreso' AND "+ "cl.edad = 
    (SELECT MAX(cl2.edad) FROM Cliente cl2) "
    + "GROUP BY realizantes.numCuenta, cl.Nombre, cl.edad ORDER BY 
    SUM(op.importe) DESC";

    javax.persistence.Query query5 = em.createQuery(query_text);
   	@SuppressWarnings("unchecked")
    List<Query5> results = 
    query5.unwrap(org.hibernate.query.Query.class)
    .setResultTransformer(new Query5Transformer()).getResultList();

   	System.out.println("------ Mostrando Query5 en JPQL ------");

  	for (Query5 q : results) {
   		System.out.println(q);
  	}
\end{lstlisting}

El código para la versión de esquema lógico creado es el siguiente:
\begin{lstlisting}
EntityManager em = emf.createEntityManager();
String query_text = 
  	"SELECT cl.Nombre, realizantes.numCuenta, SUM(op.importe), cl.Edad"
	+ "FROM Operacion op JOIN op.realizante realizantes "
  	+ "JOIN realizantes.propietarios cl " + "WHERE op.tipo =
  	'Retirada' AND "
	+ "cl.Edad = (SELECT MAX(cl2.Edad) FROM Cliente cl2) "
	+ "GROUP BY realizantes.numCuenta, cl.Nombre, cl.Edad ORDER BY 			
	SUM(op.importe) DESC";

javax.persistence.Query query5 = em.createQuery(query_text);
@SuppressWarnings("unchecked")
List<Query5> results = query5.unwrap(org.hibernate.query.Query.class)
.setResultTransformer(new Query5Transformer()).getResultList();

System.out.println("------ Mostrando Query5 en JPQL ------");

for (Query5 q : results) {
      	System.out.println(q);
  	}
\end{lstlisting}

\section{Conclusiones y opiniones}

\textbf{Meter aqui las conclusiones y opiniones del equipo ante el uso de este ORM.}


\newpage
\section{Apéndice 1: Figuras}

\begin{landscape}
\begin{figure}
\centering
\includegraphics[scale=0.75]{images/diagramaer.png}
\caption{Diagrama ER de la Base de Datos bancaria de \emph{Banquito}}
\label{fig:diagramaer}
\end{figure}
\end{landscape}

\begin{figure}
\centering
\includegraphics[scale=0.45]{images/diagramauml.png}
\caption{Diagrama de clases UML de la Base de Datos bancaria de \emph{Banquito}}
\label{fig:diagramauml}
\end{figure}

\begin{figure}
\centering
\includegraphics[scale=1]{images/estructuraMAVEN.png}
\caption{Estructura de un proyecto con la herramienta \emph{Apache Maven}}
\label{fig:estructuraMAVEN}
\end{figure}

\begin{landscape}
\begin{figure}
\centering
\includegraphics[scale=0.4]{images/mavenCentral.png}
\caption{Resultado de la búsqueda del Driver \emph{JDBC} de \emph{Oracle} en \emph{Maven Central}}
\label{fig:mavenCentral}
\end{figure}
\end{landscape}

\end{document}